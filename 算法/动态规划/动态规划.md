# 动态规划

## 思想

感觉很像高中数列的思想，给出首项，以及一个递推公式，让你求任一项的值。

## 步骤

1.  寻找状态转移方程
2.  建立合适的数据结构表
3.  填表

## 题目

### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

>   假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。
>
>   每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢

#### 思路

到达第 n 级阶梯可以从 n - 1 级走一步，或者 n - 2 级走两步，所以第 n 级有 `dp[n - 1] + dp[n - 2]` 种方法

#### 答案

```typescript
function climbStairs(n: number): number {
  const dp: number[] = []
  dp[0] = 0
  dp[1] = 1
  dp[2] = 2
  
  for(let i = 3; i <= n; i++) {
    dp[i] = dp[i - 2] + dp[i - 1]
  }
  
  return dp[n]
}
```

### [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

>   你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>   给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

#### 思路

由于不可以偷盗相邻的房屋，所以第 n 间房屋可盗窃的最大值要么是第 n - 1 间房屋可盗窃的最大值，要么是第 n - 2 个房屋可盗窃的最大值加上当前房屋可盗窃的价值，即 `dp[n] = Number.max(dp[n - 1], dp[n - 2] + n)`

#### 答案

```typescript
function rob(nums: number[]): number {
  const n = nums.length
  if(!n) return 0
  if(n === 1) return nums[0]
  
  const dp: number[] = []
  dp[0] = nums[0]
  dp[1] = Number.max(nums[0], nums[1]) // 第二间可盗窃的最大值要么是他自己，要么是他上一间房，符合动态公式
  
  for(let i = 2; i < n; i++) {
    dp[i] = Number.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  
  return dp[n - 1]
}
```

### [最大正方形](https://leetcode-cn.com/problems/maximal-square/)

>   在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积

#### 思路

题目要求最大正方形的面积，所以需要找出最大正方形的边长。

在矩阵中找最大正方形，矩阵中只有 0｜1，全部为 1 才是正方形。

如何知道哪里是 0，哪里是 1，需要穷举，但不需要全部列出，即为动态规划。

动态规划第一步，先假设我们创建了一个二维数组 dp，用来存储 **这个点为右下角的最大正方形的边长**。

下面开始找状态转换方程

思路：

假设有矩阵如下

```js
/**
 * 1 0 1 1 1
 * 1 1 1 1 1
 * 1 1 1 1 1
 * 1 0 0 1 1
 */
```

我们随便找一个点，例如最右下角的点，设该点最大正方形的边长为 `dp[i][j]`，我们用估算一下 `dp[i][j] === 2`，为什么呢？

因为我们看到 `dp[i - 1][j]`、`dp[i - 1][j - 1]`、`dp[i][j - 1]` 这三个点都是 1，又因为 `dp[i - 2][j]` 是 0，所以 `dp[i][j] === 2`。

也就是说，我们不单只是看这三个相邻点，还要看 **这三个相邻点为正方形右下角的边长情况**，找出它们中的最小值即为 `dp[i][j]` 的值，也就是这个点的最长变长。

转换公式为：

```js
dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1
```

#### 答案

```typescript
function maximalSquare(matrix: string[][]): number {
	const rows = matrix.length;
  if (!rows) return 0;
  const cols = matrix[0].length;
  const dp: number[][] = [];
  let max = 0;

  for (let i = 0; i < rows + 1; i++) {
    if (i === 0) {
      dp[i] = Array(cols + 1).fill(0);
    } else {
      dp[i] = [0];
    }
  }

  for (let i = 1; i < rows + 1; i++) {
    for (let j = 1; j < cols + 1; j++) {
      if (matrix[i - 1][j - 1] === "1") {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1;
        max = Math.max(max, dp[i][j]);
      } else {
        dp[i][j] = 0;
      }
    }
  }

  return max * max;
}
```

