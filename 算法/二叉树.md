# 二叉树

## 遍历系列

### [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```typescript
// 递归
function pre(root: TreeNode): void {
  if(!root) return
  console.log(root.val)
  pre(root.left)
  pre(root.right)
}

// 迭代
function pre(root: TreeNode): number[] {
  if(!root) return []
  const res: number[] = []
  const stack: TreeNode = [root]
  
  while(stack.length) {
    const node = stack.pop()
    res.push(node.val)
    node.right && stack.push(node.right)
    node.left && stack.push(node.left)
  }
  
  return res
}
```

### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```typescript
// 递归
function mid(root: TreeNode): void {
  if(!root) return
  mid(root.left)
  console.log(root.val)
  mid(root.right)
}

// 迭代
function mid(root: TreeNode): number[] {
  if(!root) return []
  const res: number[] = []
  const stack: TreeNode[] = [root]
  
  while(stack.length) {
    while(root) {
      stack.push(root)
      root = root.left
    }
    const node = stack.pop()
    res.push(node.val)
    root = node.right
  }
  
  return res.slice(0, res.length - 1)
}
```

### [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```typescript
// 递归
function post(root: TreeNode): void {
  if(!root) return
  post(root.left)
  post(root.right)
  console.log(root.val)
}

// 迭代
function post(root: TreeNode): number[] {
  if(!root) return []
  const res: number[] = []
  const stack: TreeNode[] = [root]
  while(stack.length) {
    const node = stack.pop()
    res.push(node.val)
    node.left && stack.push(node.left)
    node.right && stack.push(node.right)
  }
  
  return res.reverse()
}
```

### [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```typescript
function level(root: TreeNode): number[][] {
  const res: number[][] = []
  
	function recursion(node: TreeNode, level: number): void {
    if(!node) return 
    res[level] = res[level] || []
    res[level].push(node.val)
    
    recursion(node.left, level + 1)
    recursion(node.right, level + 1)
  }
  
  recursion(root, 0)
  
  return res
}
```

## 遍历变种

### [二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

>   给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

```typescript
function zigzagLevelOrder(root: TreeNode | null): number[][] {
  const res: number[][] = [];

  function traverse(node: TreeNode | null, level: number): void {
    if (!node) return;
    res[level] = res[level] || [];
    if (level % 2 === 0) {
      res[level].push(node.val);
    } else {
      res[level].unshift(node.val);
    }
    traverse(node.left, level + 1);
    traverse(node.right, level + 1);
  }

  traverse(root, 0);

  return res;
}
```

## 根据已知二叉树，求出具体值

### [求二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

>   给定一个二叉树，找出其最大深度。
>
>   二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
>   **说明:** 叶子节点是指没有子节点的节点。

```typescript
function maxDepth(root: TreeNode | null): number {
  if (!root) return 0;

  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

### [二叉搜索树中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。
>
>说明：
>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

```typescript
function kthSmallest(root: TreeNode | null, k: number): number {
  let res: number;

  function mid(node: TreeNode | null): void {
    if (!node) return;
    mid(node.left);
    if (k === 0) return;
    else {
      res = node.val;
      k--;
    }
    mid(node.right);
  }

  mid(root);

  return res;
}
```

### [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

>   给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

```typescript
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode, q: TreeNode): TreeNode {
  if(!root || root === p || root === q) return root
  
  const left = lowestCommonAncestor(root.left, p, q)
  const right = lowestCommonAncestor(root.right, p, q)
  
  if(left && right) {
    return root
  }
  
  return left || right
}
```

### [二叉树直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

>   给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

```typescript
function diameterOfBinaryTree(root: TreeNode | null): number {
  let max = 0;

  function dfs(node: TreeNode | null): number {
    if (!node) return 0;
    const left = dfs(node.left);
    const right = dfs(node.right);

    max = Math.max(max, left + right);

    return Math.max(left, right) + 1;
  }

  dfs(root);
  return max;
}
```

### [求根到叶子结点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

>   给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
>
>   例如，从根到叶子节点路径 1->2->3 代表数字 123。
>
>   计算从根到叶子节点生成的所有数字之和。
>

```typescript
function sumNumbers(root: TreeNode | null): number {
  let ans = 0;

  function dfs(node: TreeNode | null, s: string) {
    if (!node) return;
    s = s + node.val;
    if (!node.left && !node.right) {
      ans += +s;
      return;
    }
    dfs(node.left, s);
    dfs(node.right, s);
  }

  dfs(root, "");

  return ans;
}
```

