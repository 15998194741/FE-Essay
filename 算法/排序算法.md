# 排序算法

## 冒泡排序

### 概念

比较两个记录键值的大小，如果这两个记录键值的大小出现逆序，则交换这两个记录。

![img](https://user-gold-cdn.xitu.io/2020/5/31/17268eba8157dbde?imageslim)

### 实现

```typescript
function bubbleSort(list: number[]): number[] {
  for(let i = 1; i < list.length; i++) {
    for(let j = i; j > 0; j--) {
      if(list[j] > list[i]) {
        [list[j], list[j - 1]] = [list[j - 1], list[j]]
      }
    }
  }
  return list
}
```

## 快速排序

### 概念

在 n 个记录中取某一个记录的键值为标准，通常取第一个记录键值为基准，通过一趟排序将待排的记录分为小于或等于这个键值的两个独立的部分，这是一部份的记录键值均比另一部分记录的键值小，然后，对这两部分记录继续分别进行快速排序，以达到整个序列有序。

![img](https://user-gold-cdn.xitu.io/2020/5/31/17268eba844a4e72?imageslim)

### 实现

```typescript
function quickSort(list: number[]): number[] {
  // 默认状态下的比较函数
  function compare(a: number, b: number): number {
    if(a === b) return 0
    return a < b ? -1 : 1
  }
  
  // 换位函数
  function swap(list: number[], a: number, b: number): void {
    [list[a], list[b]] = [list[b], list[a]]
  }
  
  // 分治函数
  function partition(list: number[], left: number, right: number): number {
    const pivot = list[Math.floor((left + right) / 2)]
    let i = left
    let j = right
    
    while(i <= j) {
      while(compare[list[i], pivot] === -1) i++
      while(compare[list[j], pivot] === 1) j--
      
      if(i <= j) {
        swap(list, i, j)
        i++
        j--
      }
    }
    return i
  }
  
  // 快排函数
  function quick(list: number[], left: number, right: number): number[] {
    let index: number
    
    if(list.length > 1) {
			index = partition(list, left, right)
      if(left < index - 1) {
        quick(list, left, index - 1)
      } 
      if(index < right) {
        quick(list, index, right)
      }
    }
    
    return list
  }
  
  return quick(list, 0, list.length - 1)
}
```

