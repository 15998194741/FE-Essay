# 二分法

## 思想

针对有序数组进行查找时，优先考虑二分法。

## 题目

### 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素

>   例如：数组 `[3, 4, 5, 1, 2]` 为数组 `[1, 2, 3, 4, 5]` 的一个旋转，该数组的最小值为 1.
>
>   给出所有元素都大于 0，若数组长度为 0，则返回 0

#### 思路

1.  原数组为旋转数组，所以分界点前后都是有序的
2.  进行二分查找，注意因为找最小值，high 赋值时应该从 mid 开始取，mid 可能是最小值

#### 答案

```typescript
function minNumberInRotateArray(rotateArray: number[]): number {
  const n = rotateArray.length
  if(!n) return 0
  
  let left = 0, right = n - 1
  while(left < right) {
    let mid = Math.floor((right + left) / 2)
    if(rotateArray[left] <= rotateArray[right]) {
      return rotateArray[left]
    }
    if(rotateArray[left] < rotateArray[mid]) {
      left = mid + 1
    } else if(rotateArray[right] > rotateArray[mid]) {
      right = mid
    } else {
      left++
    }
  }
}
```

### 统计一个数字在排序数组中出现的次数

```typescript
function getNumberOfK(data: number, k: number): number {
  let low = 0, high = data.length - 1
  let post, count = 0
  
  while(low < high) {
    let mid = Math.floor((low + high) / 2)
    if(data[mid] === k) {
      post = mid
      break
    } else if(data[mid] < k) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }
  
  if(post !== undefined) {
    count++
    let left = post, right = post
    while(left--) {
      if(data[left] === k) {
        count++
      } else {
        break
      }
    }
    while(right++) {
      if(data[right] === k) {
        count++
      } else {
        break
      }
    }
    return count
  } else return 0
}
```

### [0~n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

>   一个长度为 n-1 的递增排序数组中所有数字都是唯一的，并且每个数字都在范围 0 ～ n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组，请找出这个数字。

#### 思路

*   left 指向0，right 指向最后一个元素
*   计算中间坐标 mid：
    *   如果 mid = nums[mid]，说明 `[0, mid]` 范围内不缺失数字，left 更新为 mid + 1
    *   如果 mid < nums[mid]，说明 `[mid, right] ` 范围内不缺失数字，right 更新为 mid - 1
*   检查 left 是否小于等于 mid，若成立，返回第二步，否则继续往下执行
*   返回 left

#### 答案

```typescript
function missingNumber(nums: number[]) {
  let left = 0, right = nums.length - 1
  while(left <= right) {
    const mid = Math.floor((left + right) / 2)
    if(mid === nums[mid]) {
      left = mid + 1
    } else {
      right = mid -1
    }
  }
  return left
}
```

### [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

>   给定一个无序的整数数组，找到其中最长上升子序列的长度。
>
>   示例：
>
>   输入：`[10, 9, 2, 5, 3, 7, 101, 18]`
>
>   输出：4
>
>   解释：最长上升的子序列是 `[2, 3, 7, 101]`，它的长度是 4

#### 思路

1.  维护一个子序列存放当前的上升序列
2.  将当前数与子序列最大值比较，如果比最大值大直接加入队尾，如果更新则找一个合适的位置替换当前的元素

#### 答案

```typescript
function lengthOfLIS(nums: number[]): number {
  const n = nums.length
  if(n <= 1) return n
  
  const tail = [nums[0]]
  for(let i = 0; i < n; i++) {
    if(nums[i] > tail[tail.length - 1]) {
      tail.push(nums[i]) // 思路 1
    } else {
      let left = 0
      let right = tail.length - 1
      while(left < right) {
        let mid = Math.floor((left + right) / 2)
        if(tail[mid] < nums[i]) {
          left = mid + 1
        } else {
          right = mid
        }
      }
      tail[left] = nums[i]
    }
  }
  return tail.length
}
```

### [搜索二维矩阵II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

>   编写一个高效的算法来搜索  *m* x *n* 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
>
>   *   每行的元素从左到右升序排列
>   *   每列的元素从上到下升序排列

#### 思路

输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

1.  选取左下角的值作为初始值 key
2.  如果目标值大于 key，因为是最左边的值（最小），所以 col++
3.  如果目标值小于 key，那么更小的值只能是上一行，所以 row--

### 答案

```typescript
function searchMatrix(matrix: number[][], target: number): boolean {
  const rows = matrix.length
  if(rows <= 0) return false
  const cols = matrix[0].length
  if(cols <= 0) return false
  
  let row = rows - 1
  let col = 0
  while(row >= 0 && col < cols) {
    if(matrix[row][col] > target) {
      row--
    } else if(matrix[row][col] < target) {
      col++
    } else return true
  }
  return false
}
```

