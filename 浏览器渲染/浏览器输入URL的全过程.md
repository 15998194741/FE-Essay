# 网络篇

假设你在网站上输入了 https://github.com/i-want-offer/FE-Interview-questions。

## 准备动作

现代浏览器会在你输入的过程中就开始智能匹配 URL，它会从书签、历史记录等地方，找到已经输入的字符串可能匹配到的 URL，然后智能显示出来，让你补全 URL。对于 Google Chrome，它甚至可以从缓存中把页面展示出来，也就是说，此时你还没有按下 Enter 进行搜索，页面就已经显示出来了。

## 构建请求

浏览器会构建请求行：

```http
GET / HTTP/1.1
// 请求方法是GET，路径为根路径，HTTP协议版本为1.1
```

## 使用缓存

在发送请求之前，浏览器会检查请求头设置的强缓存失效时间，如果命中则直接使用，否则进入下一步。

## DNS 解析

互联网每台机器的唯一 ID 是 IP地址，但是 IP地址不方便记忆，所以开发者发明了域名系统（DNS），将 IP地址和域名进行一一对应。

得到具体 IP地址的过程就叫做 DNS 解析。

具体的 DNS 解析流程包括：

### 查找浏览器缓存

浏览器提供了 DNS 数据缓存功能，如果一个域名已经被解析过，浏览器会把结果缓存下来，在缓存失效之前，下次处理直接走缓存，不需要经过 DNS 解析以提高加载速度。

### 查找系统 Host 文件配置

浏览器在查找不到缓存之后，会去本地硬盘 Host 文件进行查找，看看里面有没有对应域名和 IP地址的规则，如果有则使用，否则进入下一步。

### 浏览器发送 DNS 请求到本地DNS服务器

如果本地没有查找到相应的配置之后，浏览器会发送 DNS 请求到本地DNS服务器。

本地DNS服务器在接收到请求之后，会先查找递归查找自己的缓存记录，有缓存则直接返回，否则向根DNS服务器发送请求。

### 根DNS服务器

根DNS服务器在接收到本地DNS服务器之后，并不会直接返回域名和IP地址之间的对应关系，而是告诉本地DNS服务器可以到域服务器上面去查找，并给出域服务器的地址，这个过程是迭代的。

### 本地DNS服务器向域服务器发送请求

本地DNS服务器在接收到根DNS服务器的响应之后，会向对应的域服务器发送请求，例如当前例子中的域服务器是 .com域服务器。

域服务器接收到请求后，也不会直接返回域名和IP地址之间的对应关系，而是告诉本地DNS服务器，你请求的域名的解析服务器的地址。

### 本地DNS服务器向解析服务器发送请求

最后，本地DNS服务器向解析服务器发送请求，获取到了一个域名和IP地址的对应关系，本地DNS服务器把这个对应关系返回给浏览器，并缓存在自己本地。

## 建立 TCP 连接

值得注意的是，Chrome 在同一个域名下要求最多只能有 6 个 TCP 连接，超过 6 个就必须等待。

在不指定端口的情况下，在拿到域名和IP地址的对应关系之后，浏览器会以随机端口（1024～65535）向 Web 服务器程序的 80 端口发起 TCP 请求，这个连接请求进入内核的 TCP / IP 协议栈，还可能经过防火墙过滤，最终到达 Web 服务器程序，最终建立 TCP 连接。

建立 TCP 连接经过下面三个阶段：

1.  通过三次握手建立客户端和服务端之间的连接；
2.  进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认，如果发送方没有接收到这个确认的消息，就会判定当前数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化的策略，就是把 **大的数据包拆成一个个小的数据包**，一次传输到接收方，接收方按照这个小包的顺序把它们组装成完整的数据包；
3.  断开连接。断开连接需要通过四次挥手进行断开，这会在后续断开的时候讲解。

## 发送 HTTP 请求

现在 TCP 请求已经建立，浏览器和服务端可以开始通信。浏览器发送 HTTP 请求必须携带三样东西：

*   请求行
*   请求头
*   请求体

具体参考 [HTTP报文](https://github.com/i-want-offer/FE-Interview-questions/blob/master/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/HTTP%20%E6%8A%A5%E6%96%87.md)

## 服务器处理请求

服务器从固定端口接收到 TCP 报文开始，它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象供上层使用。

一般并发量大的网站，都会把同一个应用部署在多个服务中，客户端第一时间请求到的是反向代理服务器，再由代理服务器请求应用服务器。

## 响应 HTTP 请求

同请求类似，HTTP 响应也有三个必须携带的东西：

*   响应行
*   响应头
*   响应体

具体参考 [HTTP报文](https://github.com/i-want-offer/FE-Interview-questions/blob/master/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/HTTP%20%E6%8A%A5%E6%96%87.md)

响应完成之后，这时候需要判断请求头或者响应头中的 `Connection ` 字段是否为 keep-alive，表示建立持久连接。如果是，则 TCP 连接会一直保存，之后请求同一个服务的资源会复用这个连接，否则断开 TCP 连接，下次请求时再重新建立连接。

## 总结

到此为止，是浏览器输入 URL 中网络请求的部分，大致流程如下图：

![img](https://user-gold-cdn.xitu.io/2019/12/15/16f080b095268038?imageslim)



# 解析算法篇

完成网络请求和响应，如果响应头中的 `Content-Type` 是 `text/html` ，那么接下来就是浏览器的解析和渲染工作了。

首先介绍解析部分，它分为以下几个步骤：

*   构建 DOM 树
*   样式计算
*   生成布局树

## 构建 DOM 树

由于浏览器无法直接理解 HTML 字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 DOM树。DOM树本质上是一个以 document 为根节点的多叉树。

那通过什么方式进行解析呢？

### HTML 文法的本质

首先我们应该把握一点：HTML 的文法并不是 **上下文无关文法**。

>   上下文无关文法：若一个形式文法G = (N, Σ, P, S) 的产生式规则都取如下的形式：V->w，则叫上下文无关语法。其中 V∈N ，w∈(N∪Σ)* 。
>
>   其中把 G = (N, Σ, P, S) 中各个参量的意义解释一下:
>
>   1.  N 是**非终结符**(顾名思义，就是说最后一个符号不是它, 下面同理)集合。
>   2.  Σ 是**终结符**集合。
>   3.  P 是开始符，它必须属于 N ，也就是非终结符。
>   4.  S 就是不同的产生式的集合。如 S -> aSb 等等。

用人话来说就是：**上下文无关文法** 就是这个文法中所有产生式的左边都是一个非终结符。

HTML 文法是 **非上下文无关文法**，例如一个 form 标签，如果它的父元素也是一个 form 标签，那么解析器会跳过它。

### 解析算法

H5 规范详细地介绍了解析算法，这个算法分为两个阶段：

1.  标记化
2.  建树

对应的就是 **词法分析** 和 **语法解析**。

#### 标记化算法

这个算法输入为 HTML文本，输出为 HTML标记。

运行逻辑大致为：

1.  遇到 `<` ，状态修改为 **标记打开**
2.  接收 `[a-zA-Z]` 的字符，会进入 **标记名称状态**，这个状态会一直保持，直到遇到 `>` ，表明标记名称记录完成，这是状态修改为 **数据状态**
3.  接下来遇到 body 标签做同样的事情。此时，html 和 body 的标记都已经录好，进入 **数据状态**，之后保持这样的状态接收里面的字符
4.  当再次遇到 `<` 的时候，回到 **标记打开**，一旦接收到下一个字符 `/` 时，这时候会创建一个 `end tag` 的 token，随后进入 **标记名称状态**，遇到 `> ` 回到 **数据状态**

#### 建树算法

之前提到过，DOM 树是一棵以 document 为根节点的多叉树。因此解析器首先会创建一个 document 对象，标记生成器会把每个标记的信息发送给 **建树器**，建树器在收到相应的标记时，会创建对应的 DOM 对象。创建这个 DOM 对象会做两件事情：

1.  将 DOM 对象加入 DOM 树中
2.  将对应标记压入存放开放元素的栈中

#### 容错机制

HTML5 实现了非常强大的 **宽容策略**，容错能力非常强，在 WebKit 中，有如下经典容错示例：

1.  使用 `</br>` 而不是 `<br>`
2.  表格离散，会自动转换成同一个表格内
3.  表单元素嵌套，会自动忽略里面的 form 元素

## 样式计算

关于样式计算，它的来源一般是三种：

1.  link 标签引用
2.  style 标签中的样式
3.  元素内联样式



