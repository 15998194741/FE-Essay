# JavaScript 设计模式

## 前言

设计模式是一个程序员进阶高级的必备技巧，也是评判一个工程师工作经验和能力的试金石。设计模式是程序员多年工作经验的凝练呢和总结，能最大限度地优化代码以及对已有代码的合理重构。作为一名合格的前端工程师，学习设计模式是对自己工作经验的另一种方式的总结和反思，也是开发高质量、高可维护性、高可扩展性的重要手段。

## 目录

1.  单例模式
2.  构造器模式
3.  建造者模式
4.  代理模式
5.  外观模式
6.  观察者模式
7.  策略模式
8.  迭代器模式

## 正文

我们先来看看总览，设计模式到底可以给我们带来什么？

![img](https://user-gold-cdn.xitu.io/2020/1/31/16ff7a982f0294db?imageslim)

*   **代码可解耦**
*   **可扩展性**
*   **可靠性**
*   **条理性**
*   **可复用性**

### 单例模式

![img](https://user-gold-cdn.xitu.io/2020/1/31/16ff7abf7257ccde?imageslim)

#### 概念

保证一个类只有一个实例，一般先判断实例是否存在，如果存在直接返回，否则创建再返回，这样就可以保证一个类只有一个实例对象。

#### 作用

*   模块间通信
*   保证某个类的对象的唯一性
*   防止变量污染

#### 注意事项

*   正确使用 this
*   闭包鄂容易造成内存泄漏，所以要及时清除不需要的变量
*   创建一个新对象的成本较高

#### 实际案例

单例模式广泛应用于不同程序语言中，在实际软件应用中应用比较多的比如电脑的任务管理器，回收站，网站的计数器，多线程的线程池等。

#### 代码实现

```js
(function(){
  // 养鱼游戏
  let fish = null
  function catchFish() {
    // 如果鱼存在,则直接返回
    if(fish) {
      return {
        fish,
        water: function() {
          let water = this.fish.getAttribute('weight')
          this.fish.setAttribute('weight', ++water)
        }
    }else {
      // 如果鱼不存在,则获取鱼再返回
      fish = document.querySelector('#cat')
      return {
        fish,
        water: function() {
          let water = this.fish.getAttribute('weight')
          this.fish.setAttribute('weight', ++water)
        }
      }
    }
  }

  // 每隔3小时喂一次水
  setInterval(() => {
    catchFish().water()
  }, 3*60*60*1000)
})()
```

### 构造器模式

![img](https://user-gold-cdn.xitu.io/2020/1/31/16ff7b35d0f90c57?imageslim)

#### 概念

用于创建特定类型的对象，以便实现业务逻辑和功能的可复用。

#### 作用

*   创建特定类型的对象
*   逻辑和业务的封装

#### 注意事项

*   注意划分好业务逻辑的边界
*   配合单例实现初始化等工作
*   构造函数命名规范（大驼峰命名）
*   new 对象的成本，把公用方法放在原型链上

#### 实际案例

构造器模式是代码的格局，也是用来考验程序员对业务代码的理解程度，它往往用于实现 JavaScript 工具库，比如：lodash。

#### 代码实现

```js
function Tools(){
  if(!(this instanceof Tools)){
    return new Tools()
  }
  this.name = 'js工具库'
  // 获取dom的方法
  this.getEl = function(elem) {
    return document.querySelector(elem)
  }
  // 判断是否是数组
  this.isArray = function(arr) {
    return Array.isArray(arr)
  }
  // 其他通用方法...
}
```

### 建造者模式

![img](https://user-gold-cdn.xitu.io/2020/1/31/16ff7b42538191e9?imageslim)

#### 概念

将一个复杂的逻辑或者功能通过有条理的分工来一步步实现。

#### 作用

*   分布创建一个复杂的对象或者实现一个复杂的功能
*   解耦封装过程，无需关注具体创建的细节

#### 注意事项

*   需要有可靠算法和逻辑支持
*   按需暴露一定的接口

#### 实际案例

建造者模式其实在很多领域也有应用，比如：

*   jquery 的 ajax 封装
*   jquery 插件封装
*   react / vue 某一具体组件的设计

#### 代码展示

```js
// canvas绘制图形验证码
(function(){
    function Gcode(el, option) {
        this.el = typeof el === 'string' ? document.querySelector(el) : el;
        this.option = option;
        this.init();
    }
    Gcode.prototype = {
        constructor: Gcode,
        init: function() {
            if(this.el.getContext) {
                isSupportCanvas = true;
                var ctx = this.el.getContext('2d'),
                // 设置画布宽高
                cw = this.el.width = this.option.width || 200,
                ch = this.el.height = this.option.height || 40,
                textLen = this.option.textLen || 4,
                lineNum = this.option.lineNum || 4;
                var text = this.randomText(textLen);
    
                this.onClick(ctx, textLen, lineNum, cw, ch);
                this.drawLine(ctx, lineNum, cw, ch);
                this.drawText(ctx, text, ch);
            }
        },
        onClick: function(ctx, textLen, lineNum, cw, ch) {
            var _ = this;
            this.el.addEventListener('click', function(){
                text = _.randomText(textLen);
                _.drawLine(ctx, lineNum, cw, ch);
                _.drawText(ctx, text, ch);
            }, false)
        },
        // 画干扰线
        drawLine: function(ctx, lineNum, maxW, maxH) {
            ctx.clearRect(0, 0, maxW, maxH);
            for(var i=0; i < lineNum; i++) {
                var dx1 = Math.random()* maxW,
                    dy1 = Math.random()* maxH,
                    dx2 = Math.random()* maxW,
                    dy2 = Math.random()* maxH;
                ctx.strokeStyle = 'rgb(' + 255*Math.random() + ',' + 255*Math.random() + ',' + 255*Math.random() + ')';
                ctx.beginPath();
                ctx.moveTo(dx1, dy1);
                ctx.lineTo(dx2, dy2);
                ctx.stroke();
            }
        },
        // 画文字
        drawText: function(ctx, text, maxH) {
            var len = text.length;
            for(var i=0; i < len; i++) {
                var dx = 30 * Math.random() + 30* i,
                    dy = Math.random()* 5 + maxH/2;
                ctx.fillStyle = 'rgb(' + 255*Math.random() + ',' + 255*Math.random() + ',' + 255*Math.random() + ')';
                ctx.font = '30px Helvetica';
                ctx.textBaseline = 'middle';
                ctx.fillText(text[i], dx, dy);
            }
        },
        // 生成指定个数的随机文字
        randomText: function(len) {
            var source = ['a', 'b', 'c', 'd', 'e',
            'f', 'g', 'h', 'i', 'j', 
            'k', 'l', 'm', 'o', 'p',
            'q', 'r', 's', 't', 'u',
            'v', 'w', 'x', 'y', 'z'];
            var result = [];
            var sourceLen = source.length;
            for(var i=0; i< len; i++) {
                var text = this.generateUniqueText(source, result, sourceLen);
                result.push(text)
            }
            return result.join('')
        },
        // 生成唯一文字
        generateUniqueText: function(source, hasList, limit) {
            var text = source[Math.floor(Math.random()*limit)];
            if(hasList.indexOf(text) > -1) {
                return this.generateUniqueText(source, hasList, limit)
            }else {
                return text
            }  
        }
    }
    new Gcode('#canvas_code', {
        lineNum: 6
    })
})();
// 调用
new Gcode('#canvas_code', {
  lineNum: 6
})
```

### 代理模式

![img](https://user-gold-cdn.xitu.io/2020/1/31/16ff7b4e4f70df0f?imageslim)

#### 概念

一个对象通过某种代理来控制另一个对象

#### 作用

*   远程代理（一个对象对另一个对象的局部代理）
*   虚拟代理（对于需要创建开销很大的对象如渲染网页大图时，可以先用缩略图代替真图）
*   安全代理（保护真是对象的访问权限）
*   缓存代理（一些开销比较大的运算提供暂时的存储，下次运算时，如果传递进来的参数跟之前相同，则可以直接返回前面存储的运算结果）

#### 注意事项

使用代理会增加代码的复杂度，所以应该有选择的使用代理。

#### 实际案例

*   通过缓存代理来优化计算性能
*   图片占位符、骨架屏、预加载等
*   合并请求 / 资源

#### 代码展示

```js
// 缓存代理
function sum(a, b){
  return a + b
}
let proxySum = (function(){
  let cache = {}
  return function(){
      let args = Array.prototype.join.call(arguments, ',');
      if(args in cache){
          return cache[args];
      }

      cache[args] = sum.apply(this, arguments)
      return cache[args]
  }
})()
```

### 外观模式

![img](https://user-gold-cdn.xitu.io/2020/1/31/16ff7b613d9e603a?imageslim)

