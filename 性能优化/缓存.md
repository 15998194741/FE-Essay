# 浏览器缓存

缓存策略的分类：

*   强缓存
*   协商缓存

缓存策略都是通过设置 HTTP Header 来实现的

浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识

浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中



## 强缓存

>   强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在 Chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control

### Expires

**缓存过期时间，用来指定资源到期的时间，是服务端的绝对时间**。也就是说，`Expires = max-age + 请求时间`，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存区数据，而无需再次请求。

**Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。

### Cache-Control

在 HTTP/1.1中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 `Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

Cache-Control 可以在请求头或者响应头中设置，并且可以组合多种命令：

![Cache-Control](https://user-gold-cdn.xitu.io/2020/5/2/171d35354aa2e7b1?imageslim)

### 对比

其实两者差别不大，区别在于诞生的时期，**两者共存的话，Cache-Control 的优先级会高于 Expires**。在某些不支持 HTTP/1.1 的环境下，Expires 就会发挥作用。目前 Expires 已经是过时的产物，现阶段主要发挥兼容的作用。

强缓存判断是否缓存的依据来自于是否超出某个时间或某个时间段，而不关心服务端文件是否已经修改，这个能会导致加载文件不是服务端最新的内容，所以我们需要协商缓存来解决问题。



## 协商缓存

>   协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：
>
>   *   协商缓存生效，返回 304 和 Not Modified
>   *   协商缓存失效，返回 200 和 请求结果
>
>   协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag

### Last-Modified 和 If-Modified-Since

浏览器在第一次访问资源时，服务器返回资源的同时，在响应头中添加 Last-Modified 的 header，值是该资源在服务器上最后的修改时间，浏览器接受缓存文件和 header；

浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次接收到请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空响应，直接从缓存读取；如果不一致，则返回新的资源文件和 200

**但是 Last-Modified 存在一些弊端**：

*   如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
*   因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

所以 HTTP/1.1 根据文件内容是否修改来决定缓存策略推出了 Etag 和 If-None-Match

### Etag 和 If-None-Match

**Etag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，Etag 就会重新生成**。浏览器在下一次加载资源向服务器发送请求时，会讲上一次返回的 Etag 值放到请求头的 If-None-Match 里，服务端只需要比对客户端传过来的 If-None-Match 与 最新的 Etag 是否一致，就可以判断资源是否被修改过。如果不匹配，则直接以常规 GET 200 回包形式返回新的资源；如果一致，则以 304 的方式通知客户端直接使用本地缓存

### 对比

*   精确度上，Etag 要优于 Last-Modified。如果负载均衡的服务器，各个服务器生成的 Last-Modified 也可能不一样
*   性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法计算出一个 hash 值
*   优先级上，服务器会优先考虑 Etag



## 缓存机制

强缓存优先于协商缓存，若强缓存生效则直接使用，若不生效则根据协商缓存判断是否拉去最新资源



## 强缓存与协商缓存的区别

**区别**：

| 缓存类型 | 获取资源形式 | 状态码              | 是否发送请求到服务器             |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（Not Modified） | 是，通过服务器来告知缓存是否可用 |

**用户行为对缓存的影响**：

| 用户操作         | Expires/Cache-Control | Last-Modified/Etag |
| ---------------- | --------------------- | ------------------ |
| 地址栏回车       | 有效                  | 有效               |
| 页面链接跳转     | 有效                  | 有效               |
| 新开窗口         | 有效                  | 有效               |
| 前进回退         | 有效                  | 有效               |
| F5 刷新          | 无效                  | 有效               |
| Ctrl+F5 强制刷新 | 无效                  | 无效               |



## from memory cache 与 from disk cache 对比

>   在 Chrome 控制台 Network 中的 size 栏通常会有三种状态
>
>   1.  from memory cache 
>   2.  from disk cache
>   3.  资源本身的大小（如：1.5k）

三种区别：

*   **from memory cache**：该资源直接从内存中获取，不会请求服务器，关闭该页面时，此资源从内存中释放
*   **from disk cache**：该资源从磁盘中取出，不会请求服务器，关闭该页面时不会从磁盘中释放
*   **资源本身大小数值**：当状态码为 200 时即时从浏览器中拉去的资源；当状态码为 304 时，该数字表示与服务端通信报文的大小，并不是资源本身的大小，资源会从本地获取

| 状态 | 类型              | 说明                                                         |
| ---- | ----------------- | ------------------------------------------------------------ |
| 200  | from memory cache | 不请求网络资源，该资源存在内存中，一般脚本、字体、图片会存在内存中 |
| 200  | from disk cache   | 不请求网络资源，该资源存在磁盘用，一般非脚本会存在内存中，如：css |
| 200  | 资源大小数值      | 资源大小数值，从服务器下载最新资源                           |
| 304  | 报文大小          | 请求服务端发现资源没有更新，使用本地资源，即命中协商缓存     |

