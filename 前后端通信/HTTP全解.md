# 前言

大厂面试，尤其是一面的时候非常喜欢问 HTTP 相关的知识，而且我们在实际工作中也会经常碰到相关的问题。



# 1. 比较 HTTP 0.9 和 HTTP 1.0

1.  http 0.9 只是一个简单的协议，只有一个 GET 方法，没有首部，目的是获取 HTML
2.  HTTP 1.0 协议新增大量内容：首部、响应码、重定向、错误、条件请求、内容编码

>   HTTP 0.9 流程：
>
>   客户端构建请求，通过 DNS 查询到 IP 地址，三次握手建立 TCP 连接，客户端发送请求，服务器响应，四次挥手断开 TCP 连接（一个来回：服务器收到请求信息，请求对应的文件如 HTML，并将数据返回客户端）

>   HTTP 1.0 流程：
>
>   客户端构建请求，通过 DNS 查询到 IP 地址，三次握手建立 TCP 连接，客户端发送请求，服务器响应，四次挥手断开 TCP 连接（多个来回：HTTP 1.0 引入了请求头和响应头，由于出现了 js、css等多种形式的文本，所以引入了 content-encoding，content-type 等字段）



# 2. 关于 HTTP 1.1 以及 HTTP 2

HTTP 1.1 中浏览器再也不需要为每个请求重新发送 TCP 连接了，增加内容有：缓存相关首部的扩展，OPTIONS 方法，Upgrade 首部，Range 请求，压缩和传输编码，管道化等。但还是为无法满足 Web 的发展需求，所以就有了 HTTP 2.0。

HTTP 2 解决了 HTTP 中的 队头阻塞问题。

使用 HTTP 2 会比 HTTP 1.1 在使用 tcp 的时候，用户体验和感知的延迟有明显的改善，以及提升了 tcp 连接的利用率（并行的实现机制不依赖于服务器建立多个连接）



# 3. HTTP 的几种请求方法用途

*   get：获取服务器上的某些资源
*   post：添加新的资源到服务器上
*   put：更新服务器上的指定资源
*   head：获取页面的首部
*   delete：删除服务器上的指定资源
*   options：获取当前 URL 所支持的所有方法
*   trace：用于激发一个远程的，应用层的请求消息回路
*   connect：把请求连接转换到 TCP/TP 通道



# 4. 从浏览器地址栏输入 url 到页面显示的步骤



# 5. Web 性能优化

其中里面的 **性能关键**：

>   什么是数据包 **数据包（IP 数据包）**，指的是在固定结构的一系列字节，它定义了数据包的长度，传输的细节，以及其他与 TCP 相关的信息。

*   延迟：指 IP 数据包从网络端点到另一个网络端点所花费的时间。（所花费的时间在于往返时延，是延迟时间的两倍）
*   带宽：只要带宽没有饱和，两个网络端点的连接会一次处理尽可能多的数据量（所以带宽可能成为性能瓶颈）
*   建立连接时间：在客户端和服务端之间建立连接往返数据（三次握手）
*   TLS 协商时间（TLS 会造成额外的往返传输）

除了网络，还有 **页面内容本身或服务器性能**，如首字节时间TTFB，内容下载时间，开始渲染时间，文档加载完成时间等。

**优化技术：**

*   DNS 查询优化
*   客户端缓存
*   优化 TCP 连接
*   避免重定向
*   网络边缘的缓存
*   条件缓存
*   压缩和代码极简化
*   图片简化



# 6.  HTTP1.1

*   改进持久连接和 CDN 域名分片机制
*   不成熟的 HTTP 管道化
*   提供虚拟主机支持
*   对动态生成的内容完美支持
*   引入 cookie 以及安全机制

对于http1的问题，迎来了http2。其中http1的问题：

队头阻塞，大多数情况下，浏览器会希望同时获取许多资源，但http1未提供机制来同时请求这些资源，如果仅是使用一个连接，需要发起请求，等待响应，然后才能发起下一个请求。

在http1中要给特性为管道化，可以允许一次发送一组请求，但是需要按照发送顺序依次接收响应。所以在请求应答过程中，如发生什么情况，剩下的工作都会被阻塞，这就是“队头阻塞”（阻塞在那次请求应答发生错误），阻碍网络传输和web页面的渲染，指导失去响应。

低效的TCP利用，TCP协议作为最可靠的协议之一，其核心是拥塞窗口。

>   拥塞窗口，是卫星通信在因特网中防止通信拥塞的一种措施，它是在发端采用了一种“拥塞避免”算法和“慢速启动”算法相结合的机制。“拥塞窗口”就是“拥塞避免”的窗口，它是一个装在发送端的可滑动窗口，窗口的大小是不超过接收端确认通知的窗口。

拥塞窗口指在接收方确认数据包之前，发送方可以发送的TCP包的数据。（如拥塞窗口指定为1的情况，那么发送方就发出1哥数据包之后，只有接收方确认了那个发出的数据包，才能发送下一个）

拥塞控制能防止过多的数据注入到网络中，用于避免网络过载，TCP中可以通过**慢启动**探索当前连接对应拥塞窗口的合适大小。即发送者发送数据的时候并非一开始注入大量数据到网络中，而是发送一个数据包进行测试，当得到确认回复后，额外发送一个未确认包。

这意味着得到一个确认回复，可以发送两个数据包，得到两个确认回复，可以发送四个数据包，以几何形式增长很快到达协议规定的拥塞窗口大小（发包数上限），这时候连接进入**拥塞避免阶段**，这种机制需要往返几次才能得知最佳拥塞窗口大小，但往返几次所需的时间成本不可忽略。

-   拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如果再考虑到接收方的接收能力，那么发送窗口还可能小于拥塞窗口。
-   发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减少一些，以减少注入到网络中的分组数。

>   tcp中的慢启动概念，是用来探索当前连接对应拥塞窗口的合适大小。用来弄清楚新连接当前的网络情况。“慢速启动”是在连接建立后，每收到一个来自收端的确认，就控制窗口增加一个段值大小，当窗口值达到“慢速启动”的限值后，慢速启动便停止工作，避免了网络发生拥塞。

>   TCP传输控制协议的设计思路是，对假设情况很保守情况下，能够公平对待同一网络的不同流量的应用，它的避免拥塞机制被设计城即使在最差的网络情况下也可以起作用。

臃肿的消息首部，HTTP/1.1能压缩请求内容，但是消息首部却不能压缩。它可能占据请求的绝大部分（也可能是全部）也是比较常见了。（在这里如果能压缩请求首部，把😙请求变得更小，就能够缓解带宽压力了，降低系统的总负载）

受限的优先级设置，即如果浏览器针对指定域名开启多个socket请求，若web页面某些资源会比另外一些资源重要，会加重资源的排队效应，会延迟请求其他的资源，优先级高的资源先获取，优先级低的资源会在资源高的资源处理完成，（在处理过程中，浏览器不会发起新的资源请求）等待高的完成后再发起请求，(这就会让总的页面下载时间延长)。

>   在请求优先级高的资源的时间区间内浏览器并不会发起优先级较低的新请求

小结：HTTP1.1慢启动影响资源首次加载速度，TCP建立连接后，会开始请求传输，开始比较慢，然后不断加快，为了防止出现网络拥堵，会让页面的首次渲染时间变长。开始多个tcp，如出现网络下降，无法识别资源的优先级，会出现竞态问题。



# 7. 如何进行网站性能优化

1.  内容方面：减少 http 请求（合并文件，css 精灵，inline image），减少 DNS 查询（DNS 缓存，将资源分布到合适数量的主机名），减少 DOM 元素的数量
2.  cookie方面：可以减少 cookie 的大小
3.  css 方面：将样式表放在文档顶部；避免使用 css 表达式；使用 `<link>` 而不是 `@import`；将 css 从外部引入；压缩 css
4.  js 方面：将脚本放在文档底部；将 js 从外部引入；压缩 js；删除不需要的脚本，减少 DOM 的访问；
5.  图片方面：压缩图片，不要在 HTML中拉伸图片。



# 8. http 状态码以及含义



# 9. http 数据压缩

数据压缩，在浏览器中发送请求时，请求头部会带有 `Content-Encoding: gzip`，里面设置浏览器支持的压缩格式列表，如 gzip、deflate、br 等。这样服务器就可以接收到一个压缩算饭，放进 `Content-Encoding ` 响应头中，再把原数据压缩后发送给浏览器。

![](https://user-gold-cdn.xitu.io/2020/6/14/172b08e8d47c61ea?imageslim)



# 10. http 分块传输

分块传输就是将一个大文件分解成多个小块，浏览器接收到之后再重新组装起来。

每个包会被分成两部分，分块长度和分块数据（长度头和数据块），长度以 CRLF 结尾的一行明文，数据块紧跟在长度头后面，也是用 CRLF 结尾，最后一个长度为 0 的块表示结束。

在响应头里用头字段 `Transfer-Encoding: chunked` 表示报文里的 body 部分不是一次性发送过来的，而是分成了许多块逐个发送的。

在 Transfer-Encoding: chunked 和 Content-Length 中，这两个字段是互斥的（一个响应报文的传输长度要么已知，要么未知）

![](https://user-gold-cdn.xitu.io/2020/6/14/172b09fa3489df62?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b0a2a83e5d591?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b0972bdb97e97?imageslim)



# 11. http 范围请求

断点续传

>   要实现该功能需要制定下载的实体范围，这种指定范围发送请求叫做范围请求。

Accept-Ranges：服务器使用http响应头Accept-Ranges标识自身支持范围请求，字段的具体值用于定义范围请求的单位。

语法

```js
Accept-Ranges: bytes,范围请求的单位是 bytes （字节）
Accept-Ranges: none,不支持任何范围请求单位
```

范围请求时用于不需要全部数据，只需要其中的部分请求时，可以使用范围请求，允许客户端在请求头里使用专用字段来表示只获取文件的一部分。

Range的格式，请求头Range是HTTP范围请求的专用字段，格式是“bytes=x-y”,以字节为单位的数据范围。



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b0c14ea510804?imageslim)



1.  “0-”表示从文档起点开始到文档结束的整个文件。
2.  “100-”表示从第100哥字节开始到文档末尾。
3.  “-10”表示从文档末尾倒数的第10个字节开始。

示例：

```js
执行范围时会使用头部字段 Range 来指定资源 byte 的范围。
Range格式：
5001-10000字节
Range : byte = 5001-10000
5000之后的
Range : byte = 5001-
0-3000字节，5001-10000字节
Range : byte=-3000,5001-10000
```



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b0c34578a2bc9?imageslim)



上图表示服务器收到Range字段后，检测范围合法性，范围越界，就会返回状态码416，如你的文件只有1000个字节，但请求范围在20000-3000，就会导致这个状态码的出现。

如果成功读取文件，范围正确，返回状态码“206”。服务器要添加一个响应头字段Content-Range,告诉片段的实际偏移量和资源的总大小。

最后是发送数据，直接把片段用TCP发给客户端，一个范围请求就算是处理完了。

>   格式是“bytes x-y/length”,与Range头区别在没有“=”



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b0c7e7ccf3d82?imageslim)



Content-Range: bytes 0-4395719/4395720



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b0c8572c4965e?imageslim)



# 12. http 多段数据

多段数据，就是在 range 头里面使用了多个"x-y"，一次性获取多个片段数据。使用一种特殊的 MIME 类型：“multipart/byterages”，用来表示响应报文包含了多个范围时使用。多重范围请求，响应会在头部 Content-Type 和 multiplart-byteranges。

多段数据图：分别标记 boundary 来区分不同的分段

![	](https://user-gold-cdn.xitu.io/2020/6/14/172b0e1450bf4bf0?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b0e4a32d294e9?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b0e4e8d3333da?imageslim)



# 13. cookie、localStorage、sessionStorage

由于 HTTP 是无状态协议，所以通信双方并不会记录各自的信息，但是在现实场景中通常都需要有一个标识用来记录个人信息，cookie的诞生便是基于这种需求。

*   cookie 是网站用来标识用户身份而储存在用户本地终端上的数据
*   cookie 数据始终在同源的 http 请求中携带，即使是不需要的情况下，所以会在服务端和客户端之间来回传递
*   sessionStorage 和 localStorage 并不会主动把数据发送给服务器，仅仅作为本地存储

>   存储大小

cookie 的大小不超过 4k；sessionStorage 和 localStorage 可以达到 5M 甚至更大

>   有效时间

*   localStorage 除了主动删除以外，会一直保留
*   sessionStorage 在当前浏览器窗口关闭之后会自动消失
*   cookie 在过期时间之前都一直有效



# 14. 为什么说利用多个域名存储网站资源更有效

因为 CDN 缓存更加方便；突破浏览器并发限制；节约 cookie 带宽；节约主域名的连接数，优化页面响应速度；防止不必要的安全性问题。



# 15. http 2.0

相比较于 http/1 的文本传输格式，http/2 的二进制格式进行数据传输的时候具有更小的负载和传输体积。

http2.0 分层：

*   分帧层（http2 多路复用的核心）
*   数据或 http 层（包含传统上被认为是 HTTP 以及其关联数据的部分）

http2.0:

*   多路复用机制：引入了二进制的分帧层机制来实现多路复用（分帧层是基于帧的二进制协议，这方便里机器解析，请求和响应交织在一起）
*   可以设置请求的优先级（客户端的分帧层对分割块标上请求的优先级）
*   头部压缩：请求头压缩，增加传输效率

>   http/2 相较于 http/1 的优点：

*   多路复用
*   头部压缩
*   资源优先级和依赖设置
*   服务端推送
*   流量控制
*   重置消息

![](https://user-gold-cdn.xitu.io/2020/6/14/172b110637f61896?imageslim)

在单个域名下仍可以建立一个TCP管道，使用一个TCP长连接，下载整个资源页面，只需要一次慢启动，并且避免了竞态，浏览器发起请求，分帧层会对每个请求进行分割，将同一个请求的分割块打上相同的id编号，然后通过协议栈将所有的分割体发送给服务器，然后通过服务器的分帧层根据id编号进行请求组装，服务器的分帧层将回应数据分割按同一个回应体进行ID分割回应给客户端，客户端拼装回应。

对于http2中的帧（frame），http1不是基于帧（frame）的，是文本分隔的。

GET/HTTP/1.1 `<crlf>`



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b1153ebe34e72?imageslim)



这样，对于http1的请求或者是响应可能有的问题：

1.  一次只能处理一个请求或者是响应，完成之前是不能停止解析的。
2.  无法预判解析需要多少内层。

HTTP/1 的请求和响应报文，是由起始行、首部和正文组成，换行符分隔；HTTP/2是将请求和响应数据分割成更小的帧，采用二进制编码，易于解析的。

参考图片：



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b11c399279634?imageslim)



>   帧结构总结 所有的帧都包含一个9 byte的帧头 + 可边长的正文不同。根据帧的类型不同，正文部分的结构也不一样。

帧头：



![img](https://user-gold-cdn.xitu.io/2020/6/14/172b11ebb1d14d28?imageslim)



# 16. HTTP2 幕后

http2 作为一个二进制协议，拥有包含轻量型，安全和快速在内的所有优势，保留了原始的 http 协议语义。

http2 的一个重要特性是基于流的流量控制，提供了客户端调整传输速度的能自，其中 WINDOW_UPDATE 帧用来指示流量控制信息。

有了多路复用，客户端可以一次发出多个资源的请求，不用像 http/1 那样，发出新对象请求前，需要等待前一个响应完成。所以浏览器失去了在 http/1 中的默认资源优先级策略。



# 17. 浏览器生成 http 请求消息

![](https://user-gold-cdn.xitu.io/2020/6/14/172b19ced1107696?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b19d534737456?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b19deeeca1f1e?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b19eda9646cf0?imageslim)

![](https://user-gold-cdn.xitu.io/2020/6/14/172b19f0e86d7a88?imageslim)



# 18. 了解网络基础知识

*   应用层：是对特定应用的协议
*   表示层：设备固有数据格式和网络标准数据格式的转换
*   会话层：通信管理，负责建立和断开通信连接
*   传输层：管理两个节点之间的数据传输
*   网络层：地址管理与路由选择
*   数据链路层：互联设备之间传送和识别数据帧
*   物理层：以“0”“1”代表电压的高低，灯光的闪灭



# 19. 有哪些渲染优化

1.  禁止使用 iframe
2.  禁止使用 gif 图片来实现 loading 动画，以降低 CPU 的消耗
3.  使用 CSS3 动画来代替 js 动画
4.  对于一些小图标，可以使用 base64 来代替图片，以减少网络请求



# 20. 学习 TCP/IP 的基础知识

TCP/IP 模型（参考 18.）



# 21. TCP/IP 是如何在媒介上传输的



# 22. http 3.0

在 http 2.0 中，TCP 管道传输途中也会导致丢包问题，造成队头阻塞（在 http 2.0 中的 TCP 建立三次握手和 HTTPS 的 TSL 连接也会比较耗时）

其实多路复用技术可以只通过一个 TCP 连接接可以传输所有的请求数据。

![](https://user-gold-cdn.xitu.io/2020/6/24/172e6a2d16585d93?imageslim)

HTTP/3 弄了一个基于 UDP 协议的 QUIC 协议，QUIC 是基于 UDP，并在此基础上增加了很多功能。



# 23. 网络中的 UDP

UPD面向报文的协议，就是UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作，在发送端，应用层将数据传给传输层的UDP协议，UDP会给数据加一个UDP头标识下是UDP协议，然后传给网络层。

接收端，网络层将数据传给传输层，UDP只去除IP报文头就传给应用层，不会任何拼接操作。

UDP是无连接，通信不需要建立和断开连接，UDP是不可靠的，不关心数据的安全等问题，UDP是没有拥塞控制，在网络条件不好的情况下可能会导致丢包。

>   传输：UDP 支持一对一，一对多，多对多，多对一的的传输方式， UDP 提供了单播，多播，广播的功能。



# 24. 网络中的 TCP

UDP没有TCP那么复杂，UDP头部开销小，但是TCP头部比UDP头部复杂得多，UDP头部只有8字节，相比TCP的至少20字节要少很多。

>   Sequence number

这个序号保证了TCP传输的报文都是有序的，对端可以通过序号顺序的拼接报文

>   Window Size

表示窗口大小，还能接收多少字节的数据

>   Acknowledgement Number

表示上一个序号的数据已经接收到，接收端期望接收的下一个字节的编号是多少

**标识符**

当ACK=1，表示确认号字段有效

当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文

当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文

当FIN=1，表示此报文段是一个释放连接的请求报文

>   性能指标 RTT

表示发送端发送数据到接收到对端数据所需的往返时间

>   小结

1.  TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议
2.  UDP（User Data Protocol，用户数据报协议）是面向非连接的协议。



# 25. 建立三次握手



# 26. HTTP 请求码



# 27. 面试时，简单说说三次握手四次挥手



# 28. HTTPS

其实HTTP协议时承载于TCP协议之上的，再HTTP和TCP之间添加一个安全协议层，SSL或者TSL（ssl/tls协议传输，包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等），则就是常说的HTTPS。



# 29. GET 和 POST 的区别



# 30. HTTP 协议的主要特点

*   简单快速
*   灵活
*   无连接
*   无状态



# 31. HTTP 报文的组成部分



# 32. HTTP 请求方法



# 33. 持久连接

在http1.0中，客户端每隔很短时间会对服务器发出请求，查看是否有新的数据，只要轮询足够快，就可以造成交互实时进行，但这个做法，会对两端造成大量的性能浪费。

对于http1.1中的长连接，使用connection:keep-alive进行长连接，客户端只请求一次，但是服务器会将继续保持连接，再次请求时，避免了重新建立连接。

注意，keep-alive不会永久保持连接，只有保持一个时间段。



# 34. 安全问题：CSRF、XSS



# 35. 从一个 HTTP 请求来看网络分层原理



# 36. HTTPS安全加密通道原理分析



# 37. HTTPS 的对称加密、非对称加密、混合加密，CA 认证

